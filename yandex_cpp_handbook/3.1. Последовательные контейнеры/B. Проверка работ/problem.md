# Проверка работ

<table>
 <tr>
    <td>Ограничение времени</td>
    <td>1 c</td>
 </tr>
 <tr>
    <td>Ограничение памяти</td>
    <td>64 Mb</td>
 </tr>
  <tr>
    <td>Ввод</td>
    <td>стандартный ввод или input.txt</td>
 </tr>
  <tr>
    <td>Вывод</td>
    <td>стандартный ввод или input.txt</td>
 </tr>
</table>

В университете проводится письменная контрольная работа. N студентов сдают свои работы в общую стопку, причем некоторые кладут свою работу сверху, а другие (считая, что чем позже их работу проверят, тем лучше) — снизу. Проверяются работы в том порядке, в котором лежат, начиная с верхней. Определите, чья работа будет проверена k-й по счёту.

## Формат ввода
Первая строка содержит одно натуральное число N, не превосходящее 10000, — число студентов.

Каждая из последующих N строк содержит фамилию студента — строку из латинских букв длиной от 2 до 10 символов, и через пробел слово top или bottom — положил этот студент свою работу сверху или снизу.

Следующая строка содержит одно целое число M от 0 до 10000 — для какого числа работ нужно определить их автора.

Следующие M строк содержат по одному числу $x_i$ от 1 до N — номер в стопке очередной интересующей нас работы.

## Формат вывода
Выведите M строк. В i-й строке выведите фамилию студента, чья работа будет проверена $x_i$-й по счёту.

## Пример 1

Ввод

      3
      Ivanov top
      Petrov top
      Sidorov bottom
      2
      1
      3

Вывод

      Petrov
      Sidorov

## Пример 2

Ввод

      3
      Ivanov top
      Ivanov bottom
      Ivanov top
      4
      1
      2
      3
      1

Вывод

      Ivanov
      Ivanov
      Ivanov
      Ivanov



### std::vector:
   * push_back(): Добавление в конец вектора в среднем имеет константную сложность O(1) (амортизированная сложность). Иногда может потребоваться перевыделение памяти и копирование всех элементов, но это происходит редко.
   * insert(vector.begin(), element): Вставка в начало вектора требует сдвига всех существующих элементов вправо, чтобы освободить место для нового элемента. Эта операция занимает линейное время O(n), где n - количество элементов в векторе. То же самое относится и к insert в произвольную позицию - сдвиг элементов после позиции вставки.

### std::deque:
   * push_front(): Добавление в начало deque имеет константную сложность O(1). deque обычно реализуется как массив массивов или список блоков памяти, поэтому добавление в начало не требует сдвига существующих элементов.
   * push_back(): Добавление в конец deque также имеет константную сложность O(1).

## Почему deque лучше для этой задачи:

В этой конкретной задаче критически важно, что мы добавляем элементы как в начало, так и в конец списка. Если бы мы использовали vector и добавляли элементы в начало (с использованием insert), то каждое такое добавление приводило бы к сдвигу всех существующих элементов, что значительно замедлило бы программу, особенно при большом количестве студентов (N <= 10000).